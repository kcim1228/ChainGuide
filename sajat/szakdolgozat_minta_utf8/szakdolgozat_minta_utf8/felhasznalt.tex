%!TEX root = minta_dolgozat.tex




\setlength{\parindent}{4em}
\setlength{\parskip}{1em}
\chapter{Felhasznált technológiák}\label{ch:FELH}

\begin{osszefoglal}
	Ebben a fejezetben a felhasznált technológiák kerülnek a középpontba. Bővebben, a \textit{Vaadin}\cite{Vaadin} és \textit{Hibernate}\cite{Hibernate} keretrendszerekről,  a \textit{MapQuest}\cite{MapQuestJsApi} és \textit{OpenCycleMap}\cite{OpenCycleMap} API-król illetve az \textit{Abstract Factory} tervezési mintáról szól a dolgozat ezen része.
\end{osszefoglal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Vaadin}\label{sec:FELH:va}

\par Az alkalmazás webes felületét a \textit{Vaadin} keretrendszer segítségével valósítottuk meg. Ez egy nyílt forráskódú webalkalmazás-keretrendszer, amellyel interaktív web tartalom készíthető \textit{Java} nyelven és a hagyományos \textit{GUI} (grafikus felhasználói felület) fejlesztéshez hasonlítható. 
\par A \textit{Vaadin} megjelenítésre a \textit{Google Web Toolkit}-et (AJAX fejlesztői eszköztár) használja, míg a szerver oldal alapját a \textit{Java Servlet}  (Java objektum, mely \textit{HTTP}\footnote{Hypertext Transfer Protocol} kérést dolgoz fel és \textit{HTTP} választ generál) technológia képezi. Maga a kódolás \textit{Java} nyelven történik, a \textit{GWT} (Google Web Toolkit) ezt \textit{Javascript} forráskódra alakítja át, ami a böngészőben kerül majd futtatásra. A \textit{GWT} csupán egy vékony megjelenítési réteg a Vaadin esetében, mivel az alkalmazás logika a szerver oldalon helyezkedik el teljes mértékben. A kommunikációra \textit{AJAX} (Asynchronous JavaScript and XML) technológiát használ, míg az adatok \textit{JSON} (Javascript Object Notation) szabvány szerint vannak kódolva.
\par A\textit{ Vaadin} előnyére szolgál az, hogy komponensei kiegészíthetők \textit{GWT}-Widgetekkel illetve lehetőség van  \textit{CSS}-el (Cascading Style Sheets) való formázásra is, ami elengedhetetlen egy felhasználóbarát felület megalkotásában. Mivel az \textit{Eclipse} rendelkezik megfelelő beépített \textit{Vaadin} modulokkal, ez is a fejlesztés javára szolgált. A \textit{GWT} fordítónak köszönhetően a legtöbb modern böngészővel kompatibilis. Mivel ezen keretrendszer esetében szükség esetén összekapcsolható a \textit{Java} a\textit{ Javascript} kóddal, a \textit{Vaadin} ebből a szemszögből is egy helyes választásnak bizonyult. A Chain-Guide alkalmazás keretén belül így könnyebben hozzá tudtunk férni a térképszolgáltató függvényeihez a \textit{MapQuest Javascipt API}-ján keresztül. 
\par A \textit{Vaadin 7} és az annál újabb verziók  (a megvalósított webalkalmazás a 7.2.4-es verziót használja) a következő webböngészőkkel kompatibilisek: \footnote{Vaadin Features: \\ \href{https://vaadin.com/features}{https://vaadin.com/features}}
\par
\begin{itemize}
  \item Google Chrome 23 vagy újabb
  \item Internet Explorer 8 vagy újabb
  \item Mozilla Firefox 17 vagy újabb
  \item Opera 15 vagy újabb
  \item Safari 6 vagy újabb 
\end{itemize}

\parEgy Vaadin alkalmazás felépítése és működése:

\parA webes modul megalkotásánál egy új Vaadin projektet hoztunk létre, az Eclipse Java IDE\footnote{ nyílt forráskódú platformfüggetlen szoftverkeretrendszer } fejlesztői környezetben, a Vaadin modul letöltésének segítségével. A projekt nevének megadása után lehetőség van konfigurálni a szükséges technológiákat, mint például a webszerver megadása vagy a Vaadin verziószámának a beállítása. Ezen műveletek végrehajtása után a Vaadin kigenerál egy kezdetleges projekt szerkezetet egy UI osztállyal, illetve a telepítésleíró (deployment descriptor) web.xml állománnyal. 

\par A Vaadin két fejlesztési modellt biztosít alkalmazásai számára: a kliens és szerver oldali modelleket. Az alkalmazás felépítését illetően a szerver oldali architektúrára kerül a hangsúly, mivel fejlesztés kizárólag szerver oldalon történik. A kliens oldal, a Vaadin Kliens-Oldali Motor (Vaadin Client-Side Engine) segítségével, mely AJAX\footnote{ Asynchronous JavaScript And XML } technológiára épül, csak megjeleníti a felhasználói felületet (UI-t) a böngészőben. Emelett, a kliens oldal a különböző widgetek használatát, fejlesztését is támogatja (Java környezetben), amik Javascriptre fordítodnak és úgy hajtódnak végre a böngészőben. A két modul (kliens és szerver) közti kommunikáció egyszerűen megvalósítható mindkét irányba.

\par Egy Vaadin alkalmazás futás közbeni architektúrája a ... ábrán látható, amely egy egyszerű illusztráció a kliens és szerver oldalak közti kapcsolatról, abban a pillatnatban amikor a kliens oldali kód már be van töltődve a böngészőbe. A ábra alapján egy Vaadin alkalmazás tartalmaz: egy kliens-oldali API-t, egy szerver-oldali API-t, különböző widgeteket és témákat mindkét oldalon (felhasználóbarát megjelenítés), illetve egy adat modellt, amely lehetővé teszi, hogy a szerver oldali komponensek közvetlenül tudjanak kapcsolódni az adatainkhoz. A kliens oldal tartalmaz még egy Vaadin Fordítot (Vaadin Compiler), amely segítségével a Java kódót Javascriptre fordítja a keretrendszer. A szerver oldali Vaadin alkalmazás servlet-ként (általában VaadinServlet) fut egy Java web szerveren, kiszolgálva a HTTP kéréseket. A Vaadin Servlet osztály fogadja a kliens kéréseit és nekik megfelelő eseményekként továbbítja őket az alkalmazásban megadott esemény-ﬁgyelőkhöz (listener) a UI-on belül. A Kliens-Oldali Motor (engine), mely a böngészőben fut, fogadja a kéréseket és végrehajta a kért változtatásokat a weboldalon.
\par A felhasználói felület (User Interface): A GUI felépítéséhez, minden Vaadin alkalmazás esetében szükség van a com.vaadin.ui.UI absztrakt osztály kiterjesztésére, ez képviseli az alkalmazás belépési pontját amikor az alkalmazás url-jét beírják aböngészőbe.
\par A felhasználói felület komponensei: A UI komponensekből épül fel. Minden szerver-oldali komponensnek van egy kliens oldali megfelelője, amelyik közvetlen kapcsolatban áll a felhasználóval. A felhasználók által kiváltott események, a szerver oldali komponenseken keresztül továbbítódnak az alkalmazás back-end részéhez.
\par Kliens-Oldali-Motor: Feladata, hogy a felhasználói felületet megjelenítse a böngészőben (kliens-oldali widgetek segítségével), vagyis fogadja a kéréseket (HTTP vagy HTTPS) és végrehajtja a nekik megfelelő változásokat a weboldalon.
\par Vaadin Servlet: A Vaadin Servlet osztály kéréseket fogad különböző kliensektől, eldönti, hogy melyik felhasználói munkamenethez (user session) tartoznak (cookiek segítségével), és a nekik megfelelő munkamenetekhez (session) továbbítja őket.
\par Témák: A Vaadin különválasztja az elemek szerkezetét és megjelenítését a felhasználói felületen. Ez utóbbira CSS-t vagy Sass-t használ.



%
\section{Hibernate}\label{sec:FELH:hi}

\par Az alkalmazás backend része a \textit{Hibernate} programkönyvtár segítségével lett kivitelezve. A \textit{Hibernate} egy \textit{ORM} (objektum-relációs leképezést megvalósító) keretrendszer \textit{Java} platformra, melynek legfőbb célja az adatbázissal történő kommunikáció leegyszerűsítése. Segítségével az adatbázisban lévő rekordokat objektumként kezelhetjük és állapotmegörző módon adattáblákban tárolhatjuk. Legfőbb jellemzője ezek mellett, hogy adatbázis függetlenséget biztosít.
\par A \textit{HQL} (Hibernate Query Language) a \textit{Hibernate} saját adatlekérdező nyelve, mely lehetőséget teremt lekérdezések írására és futtatására (\textit{SQL} tudás nélkül). A keretrendszer ezen \textit{HQL} lekérdezésekből generálja az adatbáziskezelő rendszer számára megfelelő \textit{SQL} (Structured Query Language) lekérdezéseket. Így, a fejlesztők előnyére, megkíméli őket az eredményhalmazok objektumokra történő konverziójától.
\par Az adattáblák és osztályok közti leképezéseket vagy mappinget \textit{XML} (Extensible Markup Language), esetleg \textit{Java} annotációk segítségével valósítja meg. 


\lstset{language=XML}
\begin{lstlisting}

<hibernate-mapping>
    <class name="edu.ubbcluj.backend.model.Rating" table="rating" catalog="bike" optimistic-lock="version">
        <id name="id" type="int">
            <column name="id" />
            <generator class="identity" />
        </id>
        <many-to-one name="services" class="edu.ubbcluj.backend.model.Services" fetch="select">
            <column name="serviceId" />
        </many-to-one>
        <many-to-one name="users" class="edu.ubbcluj.backend.model.Users" fetch="select">
            <column name="userId" />
        </many-to-one>
        <property name="rate" type="java.lang.Integer">
            <column name="rate" />
        </property> }
    </class>
</hibernate-mapping>
\end{lstlisting}

\par 
Az fenti példában a Chain-Guide alkalmazás Rating.hbm (Hibernate Mapping File) állomány tartalma látható. Ez az XML file az Értékelés (Rating) adattábla és a neki megfelelő modell osztály között teremti meg a kapcsolatot. A {\tt <generator class="identity" /> } tag az egyedi azonosító generálására szolgál, amely az {\tt id} nevezetű, elsődleges kulcs típusú adattagot jellemzi. A {\tt many-to-one} tag név az egy-a-többhöz kapcsolat leírására szolgál míg a {\tt  property} név alatt az olyan tábla adattagokat adjuk meg, melyek nem állnak kapcsolatban más táblák mezőivel.

\par A beépített ,,dirty check”\footnote{\textit{Hibernate} jellemzője, a keretrendszer leellenőrzi, hogy egy adott objektumon történt-e változás vagy sem, és ha igen, csak akkor hajtja vérgre a frissítést (update)} is pozitívumként emelhető ki, hiszen megakadályozza a felesleges beszúrásokat az adatbázisba. A \textit{Hibernate} esetében két féle betöltési módról beszélhetünk: lusta betöltés (lazy loading) és mohó betöltés (lazy = false). Lusta betöltés esetén csak akkor fut le a  lekérdezés, amikor először hivatkozunk az objektumra, míg a mohó esetén az már az objektum betöltésekor. Átlátható módon biztosítja a \textit{Plain Old Java Object}-ek (POJO) perzisztenciáját a felhasználók számára (az egyetlen követelmény, hogy az osztálynak legyen egy argumentum nélküli konstruktora).
%
\section{Apache Maven}\label{sec:FELH:am}

A projekt moduljainak egyszerű menedzselését a \textit{Maven} szoftver biztosította, melynek legfőbb célja az összeállítási (build)  folyamatok automatizálása. Előnyére szolgál, hogy dinamikusan is le tud tölteni komponenseket, szoftver-csomagokat, ha szükséges. Egy \textit{XML} file (POM) segítségével adhatjuk meg, hogyan legyen a projekt felépítve, milyen sorrendben legyenek buildelve a különböző modulok, illetve, hogy milyen külső függőségeket, pluginokat, komponenseket használjon. A buildelés szabványosítása által a tervezési minták terjesztése a célja.
\par Az alábbi példában egy részlet látható az alkalmazás backend\footnote{adat elérési réteg} részének a  pom.xml állományából. A részletben függőségként a \textit{Hibernate} és \textit{MySQL} csatlakozók (connector) láthatóak, amiket az adatbázissal történő kommunikációra használ a rendszer.
\textcolor{red}{ megsyamozni a kepeket!!!!!!!!!!!!!! es az ALABBI PELDA szvakahoz tenni hivatkozast}

\lstset{language=XML}
\begin{lstlisting}
<dependencies>
  	<dependency>
		<groupId>org.hibernate</groupId>
		<artifactId>hibernate-core</artifactId>
		<version>4.3.8.Final</version>
	</dependency>
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
			<version>5.1.34</version>
		</dependency>
  </dependencies>
\end{lstlisting}

\par Az összeállítási (build) folyamat automatizálására az alábbi példa emelhető ki. A példában a {\tt <build> tag}-ek közé a \textit{CSS} állományok automatikus lefordítását és frissítését kérjük a rendszertől a projekt build-elésével együtt.
\lstset{language=XML}
\begin{lstlisting}
	<build>
		<finalName>bike-web</finalName>
		<plugins>
			<plugin>
                <groupId>com.vaadin</groupId>
                <artifactId>vaadin-maven-plugin</artifactId>
                <version>7.2.4</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>clean</goal>
                            <goal>resources</goal>
                            <goal>update-theme</goal>
                            <goal>compile-theme</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
		</plugins>
	</build>
\end{lstlisting}


%
\section{MapQuest}\label{sec:FELH:mq}

Az alkalmazás esetében a térképpel kapcsolatos információkat és függvényeket a \textit{MapQuest} szolgáltatta. Ez egy amerikai ingyenes online térkép szolgáltatás, mely hazánkban is elérhető, és a webes desktop és mobil alkalmazásokat is egyaránt támogatja. A különböző API-k és szolgáltatásai révén egyszerűen integrálható. A fejlesztők számára szükséges egy \textit{AppKey} (Aplication Key), egy egyedi kulcs, mely által a \textit{MapQuest} szerverei azonosítani tudják az alkalmazásunkat, annak érdekében, hogy helyes válaszokat térítsenek vissza kéréseinkre. Ez ingyenesen igényelhető regisztráció\footnote{Application Keys (AppKeys): \\ \href{http://developer.mapquest.com/fr/web/info/account/app-keys}{http://developer.mapquest.com/fr/web/info/account/app-keys}}  által. A \textit{MapQuest}  \mbox{út-,} közlekedés- és forgalommal kapcsolatos információit alapértelmezetten az \textit{OpenStreetMap} (szabadon szerkeszthető és felhasználható térkép) szolgáltatja. E térkép kerékpár rétege az \textit{OpenCycleMap}, amely biciklis szempontból hasznos informácókat szolgáltat világszerte, beleértve Romániát is. 

\par A {\tt javacript} állományok  integrációjáról (\textit{Vaadinba} való beágyazásáról) a \textcolor{red}{referencia oda!!} részben található egy részletesebb leírás.  Röviden összefoglalva a  \textit{MapQuestJavascript API}-t nem szükséges letölteni mint különálló {\tt javascript} állomány, csupán az elérési útvonalat kell megadni  {\tt javasciptes annotáció } segítségével (az {\tt AppKey} -el együtt), hasonlóan a saját {\tt javascipt} állományok betöltéséhez. 
\lstset{language=Java}
\begin{lstlisting}
import com.vaadin.annotations.JavaScript;

@JavaScript({"http://open.mapquestapi.com/sdk/js/v7.2.s/mqa.toolkit.js?key=APPKEY","mylib.js"})

\end{lstlisting}
\textcolor{red}{ megszamozni es hivatkozni ra}

\par A \textit{Javascript Maps API} egyike a legelterjedtebb \textit{MapQuest}-es szolgáltatásoknak. Funkcionalitásait illetően lehetőséget nyújt térképes felületek létrehozásához különböző extra opciókkal (live traffic, self-localization stb.), vannak beépített útkereső függvényei, melyeknek paraméterként a {\tt bicycle} kulcsszót megadva biciklibarát útvonalak rajzoltathatóak ki a térképre. A {\tt geocoding} modul átjárhatóságot biztosít a koordinátákat tartalmazó {\tt LatLng} objektumok és a direkt módon megadott címek közt, melyek ugyanazt a pontot határozzák meg a térképen. A különböző eseménykezelő függvényeivel interaktívabbá varázsolhatók az alapműveletek, illetve a térkép objektumok is felülírhatók, személyre szabhatóak, egy felhasználóbarát felület kialakításának érdekében.  
\par 
Az alkalmazás legtöbbet használt moduljaként a {\tt Geocoding} modul emelhető ki. Konkrétabban a {\tt geocodeAndAddLocation} és a {\tt reverseGeocodeAndAddLocation} függvények hangsúlyozhatók ki, melyek segítségével a {\tt LatLng} objetumokból valós címek nyerhetők és jeleníthetők meg a térképen illetve fordítva. Ezek keretén belül a {\tt POI}\footnote{a térképen egy pontot megjelenítő objektum} objektumok is személyre szabhatóak, változtatható az ikonjuk, info-ablakuk, illetve felülirhatók a rájuk értelmezett események is (kattintás, mozgatás stb.). Az alkalmazás elengedhetetlen része a minden oldalon megjelenő térkép objektum amelyet az {\tt MQA} modul {\tt TileMap} függvényének meghívásával rajzolhatunk ki a paraméterként megadott opciókkal. Ezen paraméter egy olyan adatszerkezet, melyben megadható, hogy hova töltődjön be a térkép, mi legyen a középpontja, mekkora legyen az alapértelmezett közelítés, stb. A  {\tt Routing} modul is az alkalmazás alapját képezi, hiszen elengedhetetlen két pont közötti útvonal megjelenítéséhez. Az  {\tt AddRoute} függvénynek megadhatóak  {\tt LatLng} objektumok és címek is egyaránt. Az  {\tt options} struktúrában meghatározható a keresés típusa, például  {\tt bicycle}, amely egy olyan útvonalat jelenít meg A és B pontok között mely a legbiciklibarátabbnak nevezhető (bicikliutak, forgalom mentes utcák, kerékpárbarát környezet ). A  {\tt shortest} opcióval a fizikai értelemben vett legrövidebb útszakaszt kapjuk válaszként. Az útkeresés típusa mellett megadhatók még a megjelnítésre vonatkozó extra opciók is, amellyel rövid útmutatót is megjeleníthetünk az adott útvonalra.

\textcolor{red}{ ( majd utólag beírom a hivatkozást a gyakorlati rész megfelelő fejezetére, ahol a konkrét példák lesznek).}
%
\section{OpenCycleMap}\label{sec:FELH:ocm}

Az \textit{OpenCycleMap} az \textit{OpenStreetMap} térképes szolgáltatás egy rétege (layer). Az \textit{OpenStreetMap} (OSM) egy szabadon szerkeszthető és felhasználható térképfejlesztés. A térképek egyszerű helyismeretből vagy hordozható {\tt GPS } eszközökből, légifotókból származó adatokra épülnek, amelyeket az {\tt Open Database License} (nyílt adatbázis) tárol. A regisztrált felhasználóknak lehetőségük van szerkeszteni a vektor alapú adatokat illetve {\tt GPS} nyomvonalakat is feltölthetnek. A romániai adatok szempontjából a legjobban aktualizált térképszolgáltató, illetve biciklis információk terén a legjelentősebb.
\par 	A biciklis réteg tartalmazza az összes nemzetközileg elismert bicikliutat illetve a lokális és regionális kerékpár utak javát, ezen kívül megjeleníthetők túraútvonalak, bicikli üzletek és parkolók is egyaránt, ahol azokat a felhasználók hozzáadták a térképhez. Előnyére szolgál, hogy a változtatások (pl. ha egy új bicikli utat szeretnénk hozzáadni), 24 órán belül bekerülnek az adatbázisba, és egy-két napon belül  láthatóvá válik mindenki számára (a \ref{fig:FELH:kep1}  kép, egy általunk hozzáadott bicikliutat és szerkesztési folyamatát ábrázolják).


\begin{figure}[t]
  \centering
  \begin{tabular}{ccc}
		  \pgfimage[height=5cm]{images/cycleMapEdit}
		  &
		  \pgfimage[height=5cm]{images/cycleMap}
	\end{tabular}
  \caption[Egy általunk hozzáadott bicikliút és szerkesztési folyamata]%
  {A jobb oldalon egy általunk hozzáadott bicikliút és a bal oldalon pedig a szerkesztési folyamata látható.\\
  {\white .}\url{}}
  \label{fig:FELH:kep1}
\end{figure}





%